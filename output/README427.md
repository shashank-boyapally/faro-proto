# Arcaflow Plugin Uperf

This plugin handles all components of uperf to run the given benchmark profile.

### Operation

This plugin contains two parts: the server and the client. Both need to be running for uperf to run benchmarks.

To start the server, specify how long to run it for. It should be at least 5 seconds longer than the client is run.

```yaml
# yaml-language-server:$schema=uperf_server.input.schema.json

run_duration: 15
```

To start the client, a profile must be defined in the input.

If using arcaflow to orchistrate uperf, it is recommended that you don't over-complicate the profiles and instead break them down into the tests you want to do, then have arcaflow run them.

A a profile is comprised of groups, which are comprised of transactions, which are comprised of flowops.

For more information, see [uperf's documentation](https://uperf.org/manual.html) and the fully-documented schema for this plugin.
All options that uperf profiles support are included in the schema. If you include the schema header in your yaml files and your editor has a compatible yaml extension,
you will get suggestions and documentation provided while editing your yaml file.

Example:

```yaml
# yaml-language-server:$schema=uperf.input.schema.json

name: "netperf"
groups:
  - nthreads: 1
    transactions:
      - iterations: 1
        flowops:
          - type: "accept"
            remotehost: "server"
            protocol: "tcp"
            wndsz: 50
            tcp_nodelay: true
      - duration: "10s"
        flowops:
          - type: "write"
            size: 90
          - type: "read"
            size: 90
      - iterations: 1
        flowops:
          - type: "disconnect"
```

### Running

First, create the yaml files for the client and server inputs. You will pass these into the steps. In the examples below, I use the provided inputs from the input folder.

#### Without containers

First, create a virtual environment and install the items in the requirements.txt
```console
$ python -m venv .venv
$ source .venv/bin/activate
$ pip install poetry
$ poetry install
```

Update the `input/netperf.yaml`:
```yaml
remotehost: 127.0.0.1
```

In separate shells on the same or separate machines, you need to run both steps.

The server:
```console
$ python uperf_plugin.py -s uperf_server --file input/server_input.yaml
```

And the client:
```console
$ python uperf_plugin.py -s uperf --file input/netperf.yaml
```

#### With docker-compose or podman-compose

First, build the containers with `docker-compose build` or `podman-compose build`

Next, start the containers with `docker-compose up` or `podman-compose up`

Lastly, when it's complete, clean up with `docker-compose down` or `podman-compose down`

## Image Building

You can change this plugin's image version tag in
`.github/workflows/carpenter.yaml` by editing the
`IMAGE_TAG` variable, and pushing that change to the
branch designated in that workflow.

# Autogenerated Input/Output Documentation by Arcaflow-Docsgen Below

<!-- Autogenerated documentation by arcaflow-docsgen -->
## UPerf Run (`uperf`)

Runs uperf locally

### Input

<table><tbody>
<tr><th>Type:</th><td><code>scope</code></td><tr><th>Root object:</th><td>Profile</td></tr>
<tr><th>Properties</th><td><details><summary>groups (<code>list[<code>reference[ProfileGroup]</code>]</code>)</summary>
                <table><tbody><tr><th>Name:</th><td>groups</td></tr><tr><th>Description:</th><td>A list of groups in the profile.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>list[<code>reference[ProfileGroup]</code>]</code></td><tr><td colspan="2">
    <details>
        <summary>List items</summary>
        <table><tbody><tr><th>Type:</th><td><code>reference[ProfileGroup]</code></td><tr><th>Referenced object:</th><td>ProfileGroup</td></tr></tbody></table>
    </details>
</td></tr></tbody></table>
            </details><details><summary>name (<code>string</code>)</summary>
                <table><tbody><tr><th>Name:</th><td>name</td></tr><tr><th>Description:</th><td>The name you assign to the profile. Does not change the profile&#39;s behavior.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
            </details></td></tr>
<tr><td colspan="2"><details><summary><strong>Objects</strong></summary><details><summary>AcceptFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>engine (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>engine</td></tr><tr><th>Description:</th><td>The SSL Engine used by OpenSSL</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>port (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>port</td></tr><tr><th>Description:</th><td>The port of the remote host server</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>20000</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>protocol (<code>enum[string]</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>protocol</td></tr><tr><th>Description:</th><td>The protocol used to connect to the remote host.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;tcp&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>enum[string]</code></td><tr><td colspan="2">
        <details><summary>Values</summary>
            <ul><li><strong><code>sctp</code>:</strong> SCTP</li><li><strong><code>ssl</code>:</strong> SSL</li><li><strong><code>tcp</code>:</strong> TCP</li><li><strong><code>udp</code>:</strong> UDP</li><li><strong><code>vsock</code>:</strong> VSOCK</li></ul>
        </details>
    </td>
</tr></tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>remotehost (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>remotehost</td></tr><tr><th>Description:</th><td>The remote host server that we need to connect or accept connection from</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;127.0.0.1&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>tcp_nodelay (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>tcp_nodelay</td></tr><tr><th>Description:</th><td>Sets the TCP_NODELAY socket option.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;accept&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>wndsz (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>wndsz</td></tr><tr><th>Description:</th><td>Size of the socket send and receive buffer in bytes.
This parameter is used to set SO_SNDBUF, SO_RCVBUF flags using setsocktopt()</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>ConnectFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>engine (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>engine</td></tr><tr><th>Description:</th><td>The SSL Engine used by OpenSSL</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>port (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>port</td></tr><tr><th>Description:</th><td>The port of the remote host server</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>20000</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>protocol (<code>enum[string]</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>protocol</td></tr><tr><th>Description:</th><td>The protocol used to connect to the remote host.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;tcp&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>enum[string]</code></td><tr><td colspan="2">
        <details><summary>Values</summary>
            <ul><li><strong><code>sctp</code>:</strong> SCTP</li><li><strong><code>ssl</code>:</strong> SSL</li><li><strong><code>tcp</code>:</strong> TCP</li><li><strong><code>udp</code>:</strong> UDP</li><li><strong><code>vsock</code>:</strong> VSOCK</li></ul>
        </details>
    </td>
</tr></tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>remotehost (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>remotehost</td></tr><tr><th>Description:</th><td>The remote host server that we need to connect or accept connection from</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;127.0.0.1&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>tcp_nodelay (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>tcp_nodelay</td></tr><tr><th>Description:</th><td>Sets the TCP_NODELAY socket option.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;connect&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>wndsz (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>wndsz</td></tr><tr><th>Description:</th><td>Size of the socket send and receive buffer in bytes.
This parameter is used to set SO_SNDBUF, SO_RCVBUF flags using setsocktopt()</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>DisconnectFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>conn (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>connection id</td></tr><tr><th>Description:</th><td>If you know the connection ID, you can specify which one to disconnect.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;disconnect&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>NOPFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;NOP&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>Profile (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>groups (<code>list[<code>reference[ProfileGroup]</code>]</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>groups</td></tr><tr><th>Description:</th><td>A list of groups in the profile.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>list[<code>reference[ProfileGroup]</code>]</code></td><tr><td colspan="2">
    <details>
        <summary>List items</summary>
        <table><tbody><tr><th>Type:</th><td><code>reference[ProfileGroup]</code></td><tr><th>Referenced object:</th><td>ProfileGroup</td></tr></tbody></table>
    </details>
</td></tr></tbody></table>
        </details><details><summary>name (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>name</td></tr><tr><th>Description:</th><td>The name you assign to the profile. Does not change the profile&#39;s behavior.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>ProfileGroup (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>nprocs (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>nprocs</td></tr><tr><th>Description:</th><td>The number of processes to run, with each process running a clone of the group</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>nthreads (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>nthreads</td></tr><tr><th>Description:</th><td>The number of threads to run, with each thread running a clone of the group</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>transactions (<code>list[<code>reference[ProfileTransaction]</code>]</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>transactions</td></tr><tr><th>Description:</th><td>A list of transactions in the group</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>list[<code>reference[ProfileTransaction]</code>]</code></td><tr><td colspan="2">
    <details>
        <summary>List items</summary>
        <table><tbody><tr><th>Type:</th><td><code>reference[ProfileTransaction]</code></td><tr><th>Referenced object:</th><td>ProfileTransaction</td></tr></tbody></table>
    </details>
</td></tr></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>ProfileTransaction (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>duration (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>duration</td></tr><tr><th>Description:</th><td>How long the items in the transaction run.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>flowops (<code>list[<code>one of[string]</code>]</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>flowops</td></tr><tr><th>Description:</th><td>The flowop name for uperf.
- connect: Specifies that a connection needs to be opened.
- accept: Specifies that a connection needs to be accepted from the remote
- disconnect: Disconnects from the existing connection.
- read: Data read on the client side (from the server).
- write: Data written from the client (to the server).
- redv: Receiving a message back from the server to the client.
- sendto: A message sent from the client to the server.
- sendfile: Uses the sendfile(3EXT) function call to transfer a single file.
- sendfilev: Transfers a set of files using the sendfilev(3EXT) interface. Multiple files are randomly picked from all transferrable files (see dir below) and tranferred to the server.
- NOP: Does no operation.
- think: For period of time with the CPU idling or busy.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>list[<code>one of[string]</code>]</code></td><tr><td colspan="2">
    <details>
        <summary>List items</summary>
        <table><tbody><tr><th>Type:</th><td><code>one of[string]</code></td></tbody></table>
    </details>
</td></tr></tbody></table>
        </details><details><summary>iterations (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>iterations</td></tr><tr><th>Description:</th><td>The number of times the contents of the transaction will run.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>For limiting the rate. </td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>ReadFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>canfail (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>canfail</td></tr><tr><th>Description:</th><td>Indicates that a failure for this flowop will not cause uperf to abort. This is espcially useful in UDP where a packet drop does not constitue a fatal error. This can be also be used for example, to test a SYN flood attack (Threads connect() repeatedly ignoring errors).</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>conn (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>connection id</td></tr><tr><th>Description:</th><td>Every open connection is assigned a connection name.
 Currently, the name can be any valid integer, however, uperf could take a string in the future. conn identifies the connection to use with this flowop. This connection name is thread private.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>non_blocking (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>non_blocking</td></tr><tr><th>Description:</th><td>Use non-blocking IO. The socket/file descriptor is set the NO_BLOCK flag.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>poll_timeout (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>poll_timeout</td></tr><tr><th>Description:</th><td>If this option is set, the thread will first poll for specified duration before trying to carry out the operation. A poll timeout is returned as an error back to uperf.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>randsize_max (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>randsize_max</td></tr><tr><th>Description:</th><td>For when a random message size is desired, this sets the max random value, and the size parameter sets the minimum. Unit: bytes.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rsize (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rsize</td></tr><tr><th>Description:</th><td>Receive size in bytes.
For use with asymmetrical messages. For more contect, see description for &#34;size&#34; </td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>size (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>size</td></tr><tr><th>Description:</th><td>Unit: bytes
Amount of data that is either read or written. Uperf supports exchange of:
 - Fixed size messages
 - Asymmetrical size messages
 - Random size messages
For fixed size messages, the client and all servers used a sized fixed size for receives and transmits. For asymmetrical messages, the slaves use the size specified by the rszize parameter. The master still uses the size parameter. For a random sized message, the a uniformly distributed value between the user specifed min and max is used by the transmitting side, and the receiving side uses the max as the message size. Example: size=64 for 64 bytes per packet</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>64</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;read&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>RecvFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>canfail (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>canfail</td></tr><tr><th>Description:</th><td>Indicates that a failure for this flowop will not cause uperf to abort. This is espcially useful in UDP where a packet drop does not constitue a fatal error. This can be also be used for example, to test a SYN flood attack (Threads connect() repeatedly ignoring errors).</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>conn (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>connection id</td></tr><tr><th>Description:</th><td>Every open connection is assigned a connection name.
 Currently, the name can be any valid integer, however, uperf could take a string in the future. conn identifies the connection to use with this flowop. This connection name is thread private.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>non_blocking (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>non_blocking</td></tr><tr><th>Description:</th><td>Use non-blocking IO. The socket/file descriptor is set the NO_BLOCK flag.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>poll_timeout (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>poll_timeout</td></tr><tr><th>Description:</th><td>If this option is set, the thread will first poll for specified duration before trying to carry out the operation. A poll timeout is returned as an error back to uperf.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>randsize_max (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>randsize_max</td></tr><tr><th>Description:</th><td>For when a random message size is desired, this sets the max random value, and the size parameter sets the minimum. Unit: bytes.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rsize (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rsize</td></tr><tr><th>Description:</th><td>Receive size in bytes.
For use with asymmetrical messages. For more contect, see description for &#34;size&#34; </td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>size (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>size</td></tr><tr><th>Description:</th><td>Unit: bytes
Amount of data that is either read or written. Uperf supports exchange of:
 - Fixed size messages
 - Asymmetrical size messages
 - Random size messages
For fixed size messages, the client and all servers used a sized fixed size for receives and transmits. For asymmetrical messages, the slaves use the size specified by the rszize parameter. The master still uses the size parameter. For a random sized message, the a uniformly distributed value between the user specifed min and max is used by the transmitting side, and the receiving side uses the max as the message size. Example: size=64 for 64 bytes per packet</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>64</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;recv&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>SendFileFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>dir (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>dir</td></tr><tr><th>Description:</th><td>This parameter identifies the directory from which the files will  be transferred. The directory is search recursively to generate a list of all readable files. Example: dir=/space</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;./files&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>nfiles (<code>int</code>)</summary>
        <table><tbody><tr><th>Description:</th><td>This parameter identifies the number of files that will be transferred with each call to sendfilev(3EXT). This is used as the 3rd argument to the sendfilev(3EXT). nfiles is assumed to be 1 for the sendfile  flowop function. Example: nfiles=10</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>1</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>size (<code>int</code>)</summary>
        <table><tbody><tr><th>Description:</th><td>This parameter identifies the chunk size for the transfer. Instead of sending the whole file, uperf will send size sized chunks one at a time. This is used only if nfiles=1. Unit: bytes</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;sendfile&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>SendFileVFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>dir (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>dir</td></tr><tr><th>Description:</th><td>This parameter identifies the directory from which the files will  be transferred. The directory is search recursively to generate a list of all readable files. Example: dir=/space</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;./files&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>nfiles (<code>int</code>)</summary>
        <table><tbody><tr><th>Description:</th><td>This parameter identifies the number of files that will be transferred with each call to sendfilev(3EXT). This is used as the 3rd argument to the sendfilev(3EXT). nfiles is assumed to be 1 for the sendfile  flowop function. Example: nfiles=10</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>1</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>size (<code>int</code>)</summary>
        <table><tbody><tr><th>Description:</th><td>This parameter identifies the chunk size for the transfer. Instead of sending the whole file, uperf will send size sized chunks one at a time. This is used only if nfiles=1. Unit: bytes</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;sendfilev&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>SendtoFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>canfail (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>canfail</td></tr><tr><th>Description:</th><td>Indicates that a failure for this flowop will not cause uperf to abort. This is espcially useful in UDP where a packet drop does not constitue a fatal error. This can be also be used for example, to test a SYN flood attack (Threads connect() repeatedly ignoring errors).</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>conn (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>connection id</td></tr><tr><th>Description:</th><td>Every open connection is assigned a connection name.
 Currently, the name can be any valid integer, however, uperf could take a string in the future. conn identifies the connection to use with this flowop. This connection name is thread private.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>non_blocking (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>non_blocking</td></tr><tr><th>Description:</th><td>Use non-blocking IO. The socket/file descriptor is set the NO_BLOCK flag.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>poll_timeout (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>poll_timeout</td></tr><tr><th>Description:</th><td>If this option is set, the thread will first poll for specified duration before trying to carry out the operation. A poll timeout is returned as an error back to uperf.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>randsize_max (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>randsize_max</td></tr><tr><th>Description:</th><td>For when a random message size is desired, this sets the max random value, and the size parameter sets the minimum. Unit: bytes.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rsize (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rsize</td></tr><tr><th>Description:</th><td>Receive size in bytes.
For use with asymmetrical messages. For more contect, see description for &#34;size&#34; </td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>size (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>size</td></tr><tr><th>Description:</th><td>Unit: bytes
Amount of data that is either read or written. Uperf supports exchange of:
 - Fixed size messages
 - Asymmetrical size messages
 - Random size messages
For fixed size messages, the client and all servers used a sized fixed size for receives and transmits. For asymmetrical messages, the slaves use the size specified by the rszize parameter. The master still uses the size parameter. For a random sized message, the a uniformly distributed value between the user specifed min and max is used by the transmitting side, and the receiving side uses the max as the message size. Example: size=64 for 64 bytes per packet</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>64</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;sendto&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>ThinkFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>duration (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>think_type (<code>enum[string]</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>Think Type</td></tr><tr><th>Description:</th><td>The type of think type, either idle, whichsleeps the CPU threads, or busy, which uses CPU time.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;idle&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>enum[string]</code></td><tr><td colspan="2">
        <details><summary>Values</summary>
            <ul><li><strong><code>busy</code>:</strong> BUSY</li><li><strong><code>idle</code>:</strong> IDLE</li></ul>
        </details>
    </td>
</tr></tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;think&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>WriteFlowOp (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>canfail (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>canfail</td></tr><tr><th>Description:</th><td>Indicates that a failure for this flowop will not cause uperf to abort. This is espcially useful in UDP where a packet drop does not constitue a fatal error. This can be also be used for example, to test a SYN flood attack (Threads connect() repeatedly ignoring errors).</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>conn (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>connection id</td></tr><tr><th>Description:</th><td>Every open connection is assigned a connection name.
 Currently, the name can be any valid integer, however, uperf could take a string in the future. conn identifies the connection to use with this flowop. This connection name is thread private.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>count (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>count</td></tr><tr><th>Description:</th><td>The number of times this flowop will be executed.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>non_blocking (<code>bool</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>non_blocking</td></tr><tr><th>Description:</th><td>Use non-blocking IO. The socket/file descriptor is set the NO_BLOCK flag.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>false</code></pre></td></tr><tr><th>Type:</th><td><code>bool</code></td></tbody></table>
        </details><details><summary>poll_timeout (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>poll_timeout</td></tr><tr><th>Description:</th><td>If this option is set, the thread will first poll for specified duration before trying to carry out the operation. A poll timeout is returned as an error back to uperf.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>randsize_max (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>randsize_max</td></tr><tr><th>Description:</th><td>For when a random message size is desired, this sets the max random value, and the size parameter sets the minimum. Unit: bytes.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>rate (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rate</td></tr><tr><th>Description:</th><td>Experimental: This option causes uperf to execute this flowop at the specified rate for iterations or duration seconds.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>rsize (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>rsize</td></tr><tr><th>Description:</th><td>Receive size in bytes.
For use with asymmetrical messages. For more contect, see description for &#34;size&#34; </td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>size (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>size</td></tr><tr><th>Description:</th><td>Unit: bytes
Amount of data that is either read or written. Uperf supports exchange of:
 - Fixed size messages
 - Asymmetrical size messages
 - Random size messages
For fixed size messages, the client and all servers used a sized fixed size for receives and transmits. For asymmetrical messages, the slaves use the size specified by the rszize parameter. The master still uses the size parameter. For a random sized message, the a uniformly distributed value between the user specifed min and max is used by the transmitting side, and the receiving side uses the max as the message size. Example: size=64 for 64 bytes per packet</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>64</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td><tr><th>Units:</th><td>bytes</td></tr>
</tbody></table>
        </details><details><summary>type (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>&#34;write&#34;</code></pre></td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details></details></td></tr>
</tbody></table>

### Outputs


#### error

<table><tbody>
<tr><th>Type:</th><td><code>scope</code></td><tr><th>Root object:</th><td>UPerfError</td></tr>
<tr><th>Properties</th><td><details><summary>error (<code>string</code>)</summary>
                <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
            </details></td></tr>
<tr><td colspan="2"><details><summary><strong>Objects</strong></summary><details><summary>UPerfError (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>error (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details></td></tr>
</tbody></table>
        </details></details></td></tr>
</tbody></table>

#### success

<table><tbody>
<tr><th>Type:</th><td><code>scope</code></td><tr><th>Root object:</th><td>UPerfResults</td></tr>
<tr><th>Properties</th><td><details><summary>profile_name (<code>string</code>)</summary>
                <table><tbody><tr><th>Name:</th><td>profile_name</td></tr><tr><th>Description:</th><td>The name of the profile that was run.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
            </details><details><summary>timeseries_data (<code>map[<code>int</code>, <code>map[<code>int</code>, <code>reference[UPerfRawData]</code>]</code>]</code>)</summary>
                <table><tbody><tr><th>Name:</th><td>timeseries_data</td></tr><tr><th>Description:</th><td>Map of the transaction ID to a map of timestamp to UPerfRawData.
This result varies by input profile, due to it correlating to the transactions in the profile. It ignores zero initial results.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>map[<code>int</code>, <code>map[<code>int</code>, <code>reference[UPerfRawData]</code>]</code>]</code></td><tr><td colspan="2">
    <details>
        <summary>Key type</summary>
        <table><tbody><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
    </details>
</td></tr>
<tr><td colspan="2">
    <details>
        <summary>Value type</summary>
        <table><tbody><tr><th>Type:</th><td><code>map[<code>int</code>, <code>reference[UPerfRawData]</code>]</code></td><tr><td colspan="2">
    <details>
        <summary>Key type</summary>
        <table><tbody><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
    </details>
</td></tr>
<tr><td colspan="2">
    <details>
        <summary>Value type</summary>
        <table><tbody><tr><th>Type:</th><td><code>reference[UPerfRawData]</code></td><tr><th>Referenced object:</th><td>UPerfRawData</td></tr></tbody></table>
    </details>
</td></tr>
</tbody></table>
    </details>
</td></tr>
</tbody></table>
            </details></td></tr>
<tr><td colspan="2"><details><summary><strong>Objects</strong></summary><details><summary>UPerfRawData (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>nr_bytes (<code>int</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>nr_ops (<code>int</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details><details><summary>ns_per_op (<code>int</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details></td></tr>
</tbody></table>
        </details><details><summary>UPerfResults (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>profile_name (<code>string</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>profile_name</td></tr><tr><th>Description:</th><td>The name of the profile that was run.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>timeseries_data (<code>map[<code>int</code>, <code>map[<code>int</code>, <code>reference[UPerfRawData]</code>]</code>]</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>timeseries_data</td></tr><tr><th>Description:</th><td>Map of the transaction ID to a map of timestamp to UPerfRawData.
This result varies by input profile, due to it correlating to the transactions in the profile. It ignores zero initial results.</td></tr><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>map[<code>int</code>, <code>map[<code>int</code>, <code>reference[UPerfRawData]</code>]</code>]</code></td><tr><td colspan="2">
    <details>
        <summary>Key type</summary>
        <table><tbody><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
    </details>
</td></tr>
<tr><td colspan="2">
    <details>
        <summary>Value type</summary>
        <table><tbody><tr><th>Type:</th><td><code>map[<code>int</code>, <code>reference[UPerfRawData]</code>]</code></td><tr><td colspan="2">
    <details>
        <summary>Key type</summary>
        <table><tbody><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
    </details>
</td></tr>
<tr><td colspan="2">
    <details>
        <summary>Value type</summary>
        <table><tbody><tr><th>Type:</th><td><code>reference[UPerfRawData]</code></td><tr><th>Referenced object:</th><td>UPerfRawData</td></tr></tbody></table>
    </details>
</td></tr>
</tbody></table>
    </details>
</td></tr>
</tbody></table>
        </details></td></tr>
</tbody></table>
        </details></details></td></tr>
</tbody></table>



## UPerf Server (`uperf_server`)

Runs the passive UPerf server to allow benchmarks between the client and this server

### Input

<table><tbody>
<tr><th>Type:</th><td><code>scope</code></td><tr><th>Root object:</th><td>UPerfServerParams</td></tr>
<tr><th>Properties</th><td><details><summary>run_duration (<code>int</code>)</summary>
                <table><tbody><tr><th>Name:</th><td>run_duration</td></tr><tr><th>Description:</th><td>How long the server should run before terminating.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>60</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
            </details></td></tr>
<tr><td colspan="2"><details><summary><strong>Objects</strong></summary><details><summary>UPerfServerParams (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>run_duration (<code>int</code>)</summary>
        <table><tbody><tr><th>Name:</th><td>run_duration</td></tr><tr><th>Description:</th><td>How long the server should run before terminating.</td></tr><tr><th>Required:</th><td>No</td></tr><tr><th>Default (JSON encoded):</th><td><pre><code>60</code></pre></td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details></td></tr>
</tbody></table>
        </details></details></td></tr>
</tbody></table>

### Outputs


#### error

<table><tbody>
<tr><th>Type:</th><td><code>scope</code></td><tr><th>Root object:</th><td>UPerfServerError</td></tr>
<tr><th>Properties</th><td><details><summary>error (<code>string</code>)</summary>
                <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
            </details><details><summary>error_code (<code>int</code>)</summary>
                <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
            </details></td></tr>
<tr><td colspan="2"><details><summary><strong>Objects</strong></summary><details><summary>UPerfServerError (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td><details><summary>error (<code>string</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>string</code></td></tbody></table>
        </details><details><summary>error_code (<code>int</code>)</summary>
        <table><tbody><tr><th>Required:</th><td>Yes</td></tr><tr><th>Type:</th><td><code>int</code></td>
</tbody></table>
        </details></td></tr>
</tbody></table>
        </details></details></td></tr>
</tbody></table>

#### success

<table><tbody>
<tr><th>Type:</th><td><code>scope</code></td><tr><th>Root object:</th><td>UPerfServerResults</td></tr>
<tr><th>Properties</th><td></td></tr>
<tr><td colspan="2"><details><summary><strong>Objects</strong></summary><details><summary>UPerfServerResults (<code>object</code>)</summary>
            <table><tbody><tr><th>Type:</th><td><code>object</code></td><tr><th>Properties</th><td></td></tr>
</tbody></table>
        </details></details></td></tr>
</tbody></table>
<!-- End of autogenerated documentation -->
